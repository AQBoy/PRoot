<?xml version="1.0"?>
<html xmlns="http://www.w3.org/1999/xhtml" itemscope="" itemtype="http://schema.org/Product" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>PRoot â€” chroot, mount --bind, and binfmt_misc without privilege/setup</title><link rel="stylesheet" href="website.css" type="text/css"/><meta itemprop="name" content="PRoot"/><meta itemprop="description" content="PRoot is a user-space implementation of chroot, mount --bind,&#10;and binfmt_misc.  It relies on ptrace, an unprivileged&#10;system-call, available in every Linux kernel.  This means that users&#10;don't need any privilege or setup to do things like: using an&#10;arbitrary directory as the new root file-system or making files&#10;accessible somewhere else in the file-system hierarchy or executing&#10;programs built for another CPU architecture transparently through&#10;QEMU."/><script type="text/javascript">
	      var _gaq = _gaq || [];
	      _gaq.push(['_setAccount', 'UA-20176046-1']);
	      _gaq.push(['_trackPageview']);
	      (function() {
	      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
	      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
	      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
	      })();
	  </script></head><body><div id="title"><h1>PRoot</h1> <div class="g-plusone" data-size="small" data-annotation="none"><!--By default XSLTproc converts tags with no
	    content to self-closing tags--></div></div><div id="contents"><ul><li><a href="#description">Description</a></li><li><a href="#examples">Examples</a></li><li><a href="#download">Download</a></li><li><a href="#help">Help</a></li></ul></div><div xmlns="" class="section" id="description"><h2>Description</h2><p>PRoot is a user-space implementation of <tt>chroot</tt>, <tt>mount --bind</tt>,
and <tt>binfmt_misc</tt>.  It relies on <tt>ptrace</tt>, an unprivileged
system-call, available in every Linux kernel.  This means that users
don't need any privilege or setup to do things like: using an
arbitrary directory as the new root file-system or making files
accessible somewhere else in the file-system hierarchy or executing
programs built for another CPU architecture transparently through
QEMU.</p><p>The new root file-system, a.k.a <em>guest rootfs</em>, typically contains a
Linux distribution.  By default PRoot confines the execution of
programs to the guest rootfs only, however users can use the built-in
<em>mount/bind</em> mechanism to access files and directories from the actual
root file-system, a.k.a <em>host rootfs</em>, just as if they were part of
the guest rootfs.</p><p>When the guest Linux distribution is made for a CPU architecture
incompatible with the host one, PRoot uses the CPU emulator QEMU to
execute transparently guest programs.  It's a convenient way to
develop, to build, and to validate any guest Linux packages seamlessly
on users' computer, just as if they were in a <em>native</em> guest
environment.  That way all of the cross-compilation issues are
avoided.</p><p>PRoot can also <em>mix</em> the execution of host programs and the execution
of guest programs emulated by QEMU.  This is useful for programs that
aren't available initially in the guest environment and to speed up
build-time by using cross-compilation tools or CPU-independent
programs, like interpreters.</p><p>It is worth noting that the guest kernel is never involved, regardless
of whether QEMU is used or not.  Technically, when guest programs
perform access to system resources, PRoot translates their requests
before sending them to the host kernel.  This means that guest
programs can use host resources (devices, network, ...) just as if
they were "normal" host programs.</p></div><div xmlns="" class="section" id="examples"><h2>Examples</h2><p>In the following examples the directories <tt>/mnt/slackware-8.0</tt> and
<tt>/mnt/armslack-12.2/</tt> contain a Linux distribution respectively made
for x86 CPUs and ARM CPUs.</p><div class="section" id="chroot\ equivalent"><h3><tt>chroot</tt> equivalent</h3><p>To execute a command inside a given Linux distribution, just give
<tt>proot</tt> the path to the guest rootfs followed by the desired command.
The example below executes the program <tt>cat</tt> to print the content of
a file:</p><pre>proot /mnt/slackware-8.0/ cat /etc/motd

Welcome to Slackware Linux 8.0</pre><p>The default command is <tt>/bin/sh</tt> when none is specified. Thus the
shortest way to confine an interactive shell and all its sub-programs
is:</p><pre>proot /mnt/slackware-8.0/

$ cat /etc/motd
Welcome to Slackware Linux 8.0</pre></div><div class="section" id="mount\ --bind\ equivalent"><h3><tt>mount --bind</tt> equivalent</h3><p>The option <tt>-b</tt>, short for <tt>--bind</tt>, makes any file from the host
rootfs accessible in the confined environment just as if it were
initially part of the guest rootfs.  It is sometimes required to run
programs that rely on some specific files:</p><pre>proot /mnt/slackware-8.0/

$ ps -o tty,command
Error, do this: mount -t proc none /proc</pre><p>Works better with:</p><pre>proot -b /proc /mnt/slackware-8.0/

$ ps -o tty,command
TT       COMMAND
?        -bash
?        proot -b /proc /mnt/slackware-8.0/
?        /lib/ld-linux.so.2 /bin/sh
?        /lib/ld-linux.so.2 /usr/bin/ps -o tty,command</pre><p>Actually there's a bunch of such specific files, that's why PRoot
provides the option <tt>-B</tt> to bind automatically a pre-defined list of
recommended paths:</p><pre>proot -B /mnt/slackware-8.0/

$ ps -o tty,command
TT       COMMAND
pts/6    -bash
pts/6    proot -B /mnt/slackware-8.0/
pts/6    /lib/ld-linux.so.2 /bin/sh
pts/6    /lib/ld-linux.so.2 /usr/bin/ps -o tty,command</pre><p>The bind mechanism can also be used to relocate files and directories
in the host rootfs by using <tt>/</tt> as the path to the guest rootfs and
by specifying an alternate binding location (separated by <tt>:</tt>).  It
is quite handy to cheat programs that perform access to hard-coded
locations, like some installation scripts:</p><pre>proot -b /tmp/alternate_usr:/usr /

$ cd to/sources
$ make install
[...]
install -m 755 prog "/usr/bin"
[...] # prog was installed in "/tmp/alternate_usr/bin" actually</pre><p>It can also be used to substitute system configuration files, for
example the DNS setting:</p><pre>proot -b ./alternate_resolv.conf:/etc/resolv.conf / resolveip google.com</pre></div><div class="section" id="binfmt_misc\ equivalent"><h3><tt>binfmt_misc</tt> equivalent</h3><p>PRoot uses QEMU to execute programs built for a CPU architecture
incompatible with the host one.  From users' point-of-view, guest
programs handled by QEMU are executed transparently, that is, just
like host programs.  To enable this feature users just have to specify
which instance of QEMU they want to use with the option <tt>-q</tt> or
<tt>-Q</tt> (this latter implies <tt>-B</tt>):</p><pre>proot -Q qemu-arm /mnt/armslack-12.2/

$ cat /etc/motd
Welcome to ARMedSlack Linux 12.2</pre><p>The parameter of the <tt>-q/-Q</tt> option is actually a whole QEMU
command, for instance to enable its GDB server on port 1234:</p><pre>proot -Q "qemu-arm -g 1234" /mnt/armslack-12.2/ emacs</pre><p>PRoot allows to mix transparently the emulated execution of guest
programs and the native execution of host programs in the same
file-system namespace.  It's typically useful to extend the list of
available programs and to speed up build-time significantly.  This
mixed-execution feature is enabled by default when using QEMU, and the
content of the host rootfs is made accessible through
<tt>/host-rootfs</tt>:</p><pre>proot -Q qemu-arm /mnt/armslack-12.2/

$ file /bin/echo
[...] ELF 32-bit LSB executable, ARM [...]
$ /bin/echo 'Hello world!'
Hello world!

$ file /host-rootfs/bin/echo
[...] ELF 64-bit LSB executable, x86-64 [...]
$ /host-rootfs/bin/echo 'Hello mixed world!'
Hello mixed world!</pre><p>Since both host and guest programs use the guest rootfs as <tt>/</tt>,
users may want to deactivate explicitly cross-filesystem support found
in most GNU cross-compilation tools.  For example with GCC configured
to cross-compile to the ARM target:</p><pre>proot -Q qemu-arm /mnt/armslack-12.2/

$ export CC=/host-rootfs/opt/cross-tools/arm-linux/bin/gcc
$ export CFLAGS="--sysroot=/"   # could be optional indeed
$ ./configure; make</pre><p>As with regular files, a host instance of a program can be bound over
its guest instance.  Here is an example where the guest binary of
<tt>make</tt> is overlaid by the host one:</p><pre>proot -Q qemu-arm -b /usr/bin/make /mnt/armslack-12.2/

$ which make
/usr/bin/make
$ make --version # overlaid
GNU Make 3.82
Built for x86_64-slackware-linux-gnu</pre><p>It's worth mentioning that even when mixing the native execution of
host programs and the emulated execution of guest programs, they still
believe they are running in a native guest environment.  As a
demonstration, here is a partial output of a typical <tt>./configure</tt>
script:</p><pre>checking whether the C compiler is a cross-compiler... no</pre></div></div><div class="section" id="download"><h2>Download</h2><p>
	      PRoot sources are hosted on <a href="https://github.com/cedric-vincent/PRoot">GitHub</a>
	      and the latest release is <a href="http://software.opensuse.org/download.html?project=home:cedric-vincent&amp;package=PRoot">packaged
	      for most PC Linux distributions</a>, choose wisely ;)
	    </p></div><div class="section" id="help"><h2>Help</h2><p>Feel free to send your questions, bug reports,
	    suggestions, and patchs to <a href="mailto:proot_me@googlegroups.com">the
	    mailing-list</a> or to <a href="https://groups.google.com/forum/?fromgroups#!forum/proot_me">the
	    forum</a>, but please be sure that your answer isn't in
	    the <a href="https://github.com/cedric-vincent/PRoot/blob/master/doc/manual.txt">user
	    manual</a> first.
	    </p></div><script type="text/javascript">
	    (function() {
	    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
	    po.src = 'https://apis.google.com/js/plusone.js';
	    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
	    })();
	  </script></body></html>
